/**
 * ShinyProxy
 *
 * Copyright (C) 2016-2023 Open Analytics
 *
 * ===========================================================================
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the Apache License as published by
 * The Apache Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * Apache License for more details.
 *
 * You should have received a copy of the Apache License
 * along with this program.  If not, see <http://www.apache.org/licenses/>
 */
package eu.openanalytics.shinyproxy.controllers;

import eu.openanalytics.containerproxy.log.LogPaths;
import eu.openanalytics.containerproxy.model.runtime.Proxy;
import eu.openanalytics.containerproxy.service.LogService;
import eu.openanalytics.shinyproxy.AppRequestInfo;
import jakarta.mail.internet.MimeMessage;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

import javax.inject.Inject;
import java.io.File;
import java.util.Map;

@Controller
public class IssueController extends BaseController {

    @Inject
    LogService logService;

    @Autowired(required = false)
    JavaMailSender mailSender;

    @RequestMapping(value = "/issue", method = RequestMethod.POST)
    public ResponseEntity<Map<String, String>> postIssue(HttpServletRequest request, HttpServletResponse response) {
        IssueForm form = new IssueForm();
        form.setUserName(userService.getCurrentUserId());
        form.setCurrentLocation(request.getParameter("currentLocation"));
        AppRequestInfo appRequestInfo = AppRequestInfo.fromURI(form.getCurrentLocation());
        if (appRequestInfo != null) {
            form.setAppName(appRequestInfo.getAppName());
        }
        form.setCustomMessage(request.getParameter("customMessage"));

        // TODO this is not correct when using multiple instances, send proxyId in requests #31217
//        Proxy activeProxy = proxyService.findUserProxy(p -> p.getSpecId().equals(form.getAppName()));
//        sendSupportMail(form, activeProxy);
//
        return ResponseEntity.ok(Map.of("status", "success"));
    }

    public void sendSupportMail(IssueForm form, Proxy proxy) {
        if (supportAddress == null) throw new RuntimeException("Cannot send mail: no support address configured");
        if (mailSender == null) throw new RuntimeException("Cannot send mail: no smtp settings configured");

        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message, true);

            // Headers
            helper.setFrom(environment.getProperty("proxy.support.mail-from-address", "issues@shinyproxy.io"));
            helper.addTo(supportAddress);
            helper.setSubject("ShinyProxy Error Report");

            // Body
            StringBuilder body = new StringBuilder();
            String lineSep = System.getProperty("line.separator");
            body.append(String.format("This is an error report generated by ShinyProxy%s", lineSep));
            body.append(String.format("User: %s%s", form.userName, lineSep));
            if (form.appName != null) body.append(String.format("App: %s%s", form.appName, lineSep));
            if (form.currentLocation != null) body.append(String.format("Location: %s%s", form.currentLocation, lineSep));
            if (form.customMessage != null) body.append(String.format("Message: %s%s", form.customMessage, lineSep));

            // Attachments (only if container-logging is enabled)
            if (proxy != null) {
                LogPaths filePaths = logService.getLogs(proxy);

                if (filePaths != null) {
                    File stdout = filePaths.getStdout().toFile();
                    if (stdout.exists()) {
                        helper.addAttachment(stdout.getName(), stdout);
                        // if stderr exists add it as well (stdout may exists without stderr)
                        File stderr = filePaths.getStderr().toFile();
                        if (stderr.exists()) {
                            helper.addAttachment(stderr.getName(), stderr);
                        }
                    } else {
                        body.append(String.format("Log (stdout): %s%s", filePaths.getStdout(), lineSep));
                        body.append(String.format("Log (stderr): %s%s", filePaths.getStderr(), lineSep));
                    }
                }
            }

            helper.setText(body.toString());
            mailSender.send(message);
        } catch (Exception e) {
            throw new RuntimeException("Failed to send email", e);
        }
    }

    public static class IssueForm {

        private String userName;
        private String appName;
        private String currentLocation;
        private String customMessage;

        public String getUserName() {
            return userName;
        }

        public void setUserName(String userName) {
            this.userName = userName;
        }

        public String getAppName() {
            return appName;
        }

        public void setAppName(String appName) {
            this.appName = appName;
        }

        public String getCurrentLocation() {
            return currentLocation;
        }

        public void setCurrentLocation(String currentLocation) {
            this.currentLocation = currentLocation;
        }

        public String getCustomMessage() {
            return customMessage;
        }

        public void setCustomMessage(String customMessage) {
            this.customMessage = customMessage;
        }
    }
}
